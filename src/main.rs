use ssh2::Session;
use std::io::prelude::*;
use std::net::TcpStream;
use text_io::read;

fn main() {
    println!("please enter the ip:port of the fortigate you want to check:");
    let socket: String = read!("{}\n");
    let tcp = TcpStream::connect(socket).unwrap();
    let mut sess = Session::new().unwrap();
    sess.set_tcp_stream(tcp);
    sess.handshake().unwrap();

    println!(" please enter the ssh user:");
    let user: String = read!("{}\n");

    println!(" please enter the ssh password:");
    let pass: String = read!("{}\n");

    sess.userauth_password(&user, &pass).unwrap();
    //  test if authentication was succesfull
    assert!(sess.authenticated());

    // the ioc as described in https://www.fortiguard.com/psirt/FG-IR-22-398
    let sslvpnd = IOCtype::IsString("sslvpnd".to_string());
    let datalibvec: Vec<String> = vec![
        "libips.bak".to_string(),
        "libgif.so".to_string(),
        "libiptcp.so".to_string(),
        "libipudp.so".to_string(),
        "libjepg.so".to_string(),
    ];
    let datalibfiles = IOCtype::IsVect(datalibvec);
    let varfile = IOCtype::IsString(".sslvpnconfigbk".to_string());
    let dataetcfile = IOCtype::IsString("wxd.conf".to_string());
    let flashfile = IOCtype::IsString("flash".to_string());
    let ipvec: Vec<String> = vec![
        "188.34.130.40".to_string(),
        "103.131.189.143".to_string(),
        "193.36.119.61".to_string(),
        "172.247.168.153".to_string(),
        "139.180.184.197".to_string(),
        "66.42.91.32".to_string(),
        "158.247.221.101".to_string(),
        "107.148.27.117".to_string(),
        "139.180.128.142".to_string(),
        "155.138.224.122".to_string(),
        "185.174.136.20".to_string(),
    ];
    let ip: IOCtype = IOCtype::IsVect(ipvec);

    println!(
        "{}",
        test_ioc(
            &sess,
            "diagnose debug crashlog read | grep 'Application crashed'",
            &sslvpnd
        )
    );
    println!(
        "{}",
        test_ioc(&sess, "fnsysctl ls -l /data/lib/", &datalibfiles)
    );
    println!("{}", test_ioc(&sess, "fnsysctl ls -l /var/", &varfile));
    println!(
        "{}",
        test_ioc(&sess, "fnsysctl ls -l /data/etc/", &dataetcfile)
    );
    println!("{}", test_ioc(&sess, "fnsysctl ls -l /", &flashfile));
    println!("{}", test_ioc(&sess, "diag sys session list", &ip))
}
/// an enumerate make it easier to check both string as vec<string> types
enum IOCtype {
    IsString(String),
    IsVect(Vec<String>),
}

/// a simple function to use the session and check them against the ioc
fn test_ioc(sess: &Session, cmd: &str, ioc: &IOCtype) -> bool {
    let mut channel = sess.channel_session().unwrap();
    channel.exec(cmd).unwrap();
    let mut s = String::new();
    channel.read_to_string(&mut s).unwrap();
    match ioc {
        IOCtype::IsString(iocdata) => {
            if s.contains(iocdata) {
                println!("it seems like ssl-vpn was exploited");
                println!("{}", s);
                return true;
            }
            return false;
        }
        IOCtype::IsVect(iocdata) => {
            let mut testresult: Vec<bool> = Vec::new();
            for i in iocdata {
                if s.contains(i) {
                    println!("it seems like ssl-vpn was exploited");
                    println!("{}", s);
                    testresult.push(true)
                }
            }
            if testresult.is_empty() {
                return false;
            };
            return true;
        }
    }
}
